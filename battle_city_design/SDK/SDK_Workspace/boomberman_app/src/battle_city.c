#include "battle_city.h"
#include "map.h"
#include "map2.h"
#include "map3.h"
#include "xparameters.h"
#include "xil_io.h"
#include "xio.h"
#include <math.h>

/*
 * GENERATED BY BC_MEM_PACKER
 * DATE: Wed Jul 08 21:00:48 2015
 */

// ***** 16x16 IMAGES *****
#define IMG_16x16_block			0x017F 		//2 - blok
#define IMG_16x16_enemy			0x023F 		//5 - nepr
#define IMG_16x16_bckgnd		0x027F 		//0 - poz
#define IMG_16x16_door			0x01FF 		//4 - vrata
#define IMG_16x16_bomberman		0x013F 		//1 - bomberm
#define IMG_16x16_brick			0x01BF 		//3 - cigla
#define IMG_16x16_bomb 			0x00FF 		//6 - bomba
// ***** MAP *****

#define MAP_BASE_ADDRESS		0x02BF 		// MAP_OFFSET in battle_city.vhd
#define MAP_X					0
#define MAP_X2					640
#define MAP_Y					4
#define MAP_W					64
#define MAP_H					56

#define REGS_BASE_ADDRESS       ( MAP_BASE_ADDRESS + MAP_WIDTH * MAP_HEIGHT )
//#define REGS_BASE_ADDRESS     (5439)

#define BTN_DOWN( b )           ( !( b & 0x01 ) )
#define BTN_UP( b )             ( !( b & 0x10 ) )
#define BTN_LEFT( b )           ( !( b & 0x02 ) )
#define BTN_RIGHT( b )          ( !( b & 0x08 ) )
#define BTN_SHOOT( b )          ( !( b & 0x04 ) )

#define TANK1_REG_L                     8
#define TANK1_REG_H                     9
/*
#define TANK_AI_REG_L                   4
#define TANK_AI_REG_H                   5
#define TANK_AI_REG_L2                  6
#define TANK_AI_REG_H2                  7
#define TANK_AI_REG_L3                  2
#define TANK_AI_REG_H3                  3
#define TANK_AI_REG_L4                  10
#define TANK_AI_REG_H4                  11
#define TANK_AI_REG_L5                  12
#define TANK_AI_REG_H5                  13
#define TANK_AI_REG_L6                  14
#define TANK_AI_REG_H6                  15
#define TANK_AI_REG_L7                  16
#define TANK_AI_REG_H7                  17
#define TANK_AI_REG_L8					18
#define TANK_AI_REG_H8					19
*/
#define BASE_REG_L						0
#define BASE_REG_H	                    1

#define BOMB_TICK_COUNT					20
#define BOMB_MAX_NUMBER					3
#define ENEMY_NUMBER					4
#define enemy1X 						19
#define enemy1Y 						3
#define enemy2X 						27
#define enemy2Y 						5
#define enemy3X 						20
#define enemy3Y 						17
#define enemy4X 						8
#define enemy4Y 						18
#define BOMBERMAN_STARTING_POSITION_X	8
#define BOMBERMAN_STARTING_POSITION_Y	3
#define DOOR_POSITION_X					18
#define DOOR_POSITION_Y					12
#define STARTING_LIFE_COUNT				3
#define ENEMY_WAIT_CYCLE_NUMBER			3

// ***** GLOBAL VARIABLES *****
int lives = STARTING_LIFE_COUNT;
int enemies_destroyed = 0;
int win_condition = 0;
int lose_condition = 0;
int active_bombs = 0;
int zameniSaExplosion = 6;
int bombs_coordinates[3][2], active_bombs_index = 0, exploding_bombs_index = 0;
int bombs_tick_counter[3] = {-1, -1, -1}; //nema postavljenih
// ***** ENEMY SPAWN LOCATIONS *****


// definicija za true i false
typedef enum {
	b_false, b_true
} bool_t;

// definicija za directione
typedef enum {
	DIR_LEFT = 0, DIR_RIGHT, DIR_UP, DIR_DOWN, DIR_STILL
} direction_t;

typedef enum {
	BACKGROUND = 0, BOMBERMAN, BLOCK, BRICK, DOOR, ENEMY, BOMB, EXPLOSION
} game_objects_t;

// struktura koja sadrzi osobine bombermana
typedef struct {
	unsigned int x;
	unsigned int y;
	unsigned int image;

	bool_t destroyed;

	unsigned int reg_l;
	unsigned int reg_h;
} characters;

// struktura koja sadrzi osobine protivnika
typedef struct{
	unsigned char x;
	unsigned char y;
	unsigned char type;
	unsigned char current_wait_cycle; //NEPRIJATELJI SU SE PREBRZO KRETALI, TAKO DA SAM UVEO OVAJ WAIT CYCLE. KADA JE WAIT CYCLE NULA ONDA SMEJU DA SE KRECU
										//WIAT CYCLE SE MENJA SVAKI PUT KADA POKUSAMO DA POMERIMO NEPRIJATELJA I TO NA SLEDECI NACIN: (current_wait_cycle++)%ENEMY_WAIT_CYCLE_NUMBER
	unsigned char destroyed;
} enemy;

characters bomberman = {
		BOMBERMAN_STARTING_POSITION_X,	         				 // x trenutni
		BOMBERMAN_STARTING_POSITION_Y, 		                     // y trenutni
		IMG_16x16_bomberman,  			 // type

		b_false,                		 // destroyed, false znaci da je ziv

		TANK1_REG_L,            		 // reg_l ?
		TANK1_REG_H             		 // reg_h ?
		};


//ZAMENJENO ZA LISTU NEPRIJATELJA
enemy enemies[4] = {
		{
				enemy1X,						// x
				enemy1Y,						// y
				5,              		        // tip objekta, 5 je za protivnike
				0,								// wait cycle
				0								// destroyed, 0 znaci da je ziv, 1 da je mrtav, unsigned int
		},

		{
				enemy2X,			    		// x
				enemy2Y,						// y
				5,              		        // tip objekta, 5 je za protivnike
				0,								// wait cycle
				0								// destroyed, 0 znaci da je ziv, 1 da je mrtav, unsigned int
		},

		{
				enemy3X,						// x
				enemy3Y,						// y
				5,              		        // tip objekta, 5 je za protivnike
				0,								// wait cycle
				0								// destroyed, 0 znaci da je ziv, 1 da je mrtav, unsigned int
		},

		{
				enemy4X,						// x
				enemy4Y,						// y
				5,              		        // tip objekta, 5 je za protivnike
				0,								// wait cycle
				0								// destroyed, 0 znaci da je ziv, 1 da je mrtav, unsigned int
		}
};


static int bomberman_win(characters *bomberman){
	if(enemies_destroyed == ENEMY_NUMBER) {
		if((bomberman->y) == DOOR_POSITION_Y && (bomberman->x) == DOOR_POSITION_X){
			return 1;
		}
	}
	return 0;
}
/*
static void detonate(int x, int y, unsigned char ** map, unsigned char bomb_power) {
	int i;
	for(i = 1; i <= bomb_power; i++) {
		int obstacle_left = obstacles_detection(x, y, map1, DIR_LEFT, i);
		int obstacle_right = obstacles_detection(x, y, map1, DIR_RIGHT, i);
		int obstacle_up = obstacles_detection(x, y, map1, DIR_UP, i);
		int obstacle_down = obstacles_detection(x, y, map1, DIR_DOWN, i);

		if(!obstacle_left) { //Ako nema prepreke
			map[y][x - i] = zameniSaExplosion;
		} else if (obstacle_left == BOMB){
			place_explosion(x - i, y, map, bomb_power);
		}

		if(!obstacle_right == BOMB) {
			map[y][x + i] = zameniSaExplosion;
		} else if (obstacle_right == BOMB){
			place_explosion(x + i, y, map, bomb_power);
		}

		if(!obstacle_up) {
			map[y - i][x] = zameniSaExplosion;
		} else if (obstacle_up == BOMB){
			place_explosion(x, y - i, map, bomb_power);
		}

		if(!obstacle_down) {
			map[y + i][x] = zameniSaExplosion;
		} else if (obstacle_down == BOMB){
			place_explosion(x, y + i, map, bomb_power);
		}
	}
}
*/

// character promenljiva je tip karaktera koji treba postaviti na mapu
static void char_spawn(characters * character) {
	Xil_Out32(
			XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + character->reg_l ),
			(unsigned int )0x8F000000 | (unsigned int )character->image);
	Xil_Out32(
			XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + character->reg_h ),
			((character->y)*16) << 16 | (character->x*16));
}

static void map_update(characters * bomberman) {
	int x, y;
	long int addr;
	win_condition = bomberman_win(bomberman);
	if(lives > 0 && win_condition == 0){
		for (y = 0; y < MAP_HEIGHT; y++) {							// base mapa
			for (x = 0; x < MAP_WIDTH; x++) {
				addr = XPAR_BATTLE_CITY_PERIPH_0_BASEADDR
						+ 4 * (MAP_BASE_ADDRESS + y * MAP_WIDTH + x);
				switch (map1[y][x]) {								//ovde menjam mapu
				case BACKGROUND:
					Xil_Out32(addr, IMG_16x16_bckgnd);
					break;
				case BOMBERMAN:
					Xil_Out32(addr, IMG_16x16_bomberman);
					break;
				case BLOCK:
					Xil_Out32(addr, IMG_16x16_block);
					break;
				case BRICK:
					Xil_Out32(addr, IMG_16x16_brick);
					break;
				case DOOR:
					Xil_Out32(addr, IMG_16x16_door);
					break;
				case ENEMY:
					Xil_Out32(addr, IMG_16x16_enemy);
					break;
				case BOMB:
					Xil_Out32(addr, IMG_16x16_bomb);
					break;
				default:
					Xil_Out32(addr, IMG_16x16_bckgnd);
					break;
				}
			}
		}
	}else if(lives == 0){											// game over mapa
		lose_condition = 1;
		for (y = 0; y < MAP_HEIGHT; y++) {
			for (x = 0; x < MAP_WIDTH; x++) {
				addr = XPAR_BATTLE_CITY_PERIPH_0_BASEADDR
						+ 4 * (MAP_BASE_ADDRESS + y * MAP_WIDTH + x);
				switch (map0[y][x]) {								//ovde menjam mapu
				case 0:
					Xil_Out32(addr, IMG_16x16_bckgnd);
					break;
				case 1:
					Xil_Out32(addr, IMG_16x16_bomberman);
					break;
				case 6:
					Xil_Out32(addr, IMG_16x16_bomb);
					break;
				default:
					Xil_Out32(addr, IMG_16x16_bckgnd);
					break;
				}
			}
		}
	}
	else if(lives > 0 && win_condition == 1) {									// game won mapa
		for (y = 0; y < MAP_HEIGHT; y++) {
			for (x = 0; x < MAP_WIDTH; x++) {
				addr = XPAR_BATTLE_CITY_PERIPH_0_BASEADDR
						+ 4 * (MAP_BASE_ADDRESS + y * MAP_WIDTH + x);
				switch (map3[y][x]) {								//ovde menjam mapu
				case 0:
					Xil_Out32(addr, IMG_16x16_bckgnd);
					break;
				case 1:
					Xil_Out32(addr, IMG_16x16_bomberman);
					break;
				default:
					Xil_Out32(addr, IMG_16x16_bckgnd);
					break;
				}
			}
		}
	}
}

static void map_reset(unsigned char map[30][40]) {
	unsigned int i;

	for (i = 0; i <= 20; i += 2) {
		Xil_Out32(
				XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + i ),
				(unsigned int )0x0F000000);
	}
}
/*
static int bomberman_and_enemy(characters *bomberman)
{
	unsigned int xX;
	unsigned int yY;

	xX=bomberman->x;
	yY=bomberman->y;

	if(enemy1.x==xX && enemy1.y==yY){
		return 1;
	}else if(enemy2.x==xX && enemy2.y==yY){
		return 1;
	}else if(enemy3.x==xX && enemy3.y==yY){
		return 1;
	}else if(enemy4.x==xX && enemy4.y==yY){
		return 1;
	}else {
		return 0;
	}

}*/

static int find_bomberman(characters *bomberman, int x, int y, direction_t dir, int bomb_power)
{

	unsigned int bombermanX = bomberman->x;
	unsigned int bombermanY = bomberman->y;

	switch(dir) {
	case DIR_LEFT:
		if((x - bomb_power) == bombermanX && y == bombermanY) {
			return 1;
		}
		break;
	case DIR_RIGHT:
		if((x + bomb_power) == bombermanX && y == bombermanY) {
			return 1;
		}
		break;
	case DIR_UP:
		if(x == bombermanX && (y - bomb_power) == bombermanY) {
			return 1;
		}
		break;
	case DIR_DOWN:
		if(x == bombermanX && (y + bomb_power) == bombermanY) {
			return 1;
		}
		break;
	default:;
	}
	return 0;
}

static int obstacles_detection(int x, int y, unsigned char map[30][40], direction_t dir, int position_distance) {

	int position_right = map1[y][x + position_distance];
	int position_left = map1[y][x - position_distance];
	int position_up = map1[y - position_distance][x];
	int position_down = map1[y + position_distance][x];

	if (dir == DIR_LEFT) {

		return position_left;

	} else if (dir == DIR_RIGHT) {

		return position_right;

	} else if (dir == DIR_UP) {

		return position_up;

	} else if (dir == DIR_DOWN) {

		return position_down;

	} else {
		return -1;
	}
}

// Prototip funkcije za detekciju eksplozije
static int explosion_detection(int x, int y, unsigned char map[30][40], direction_t dir, int position_distance) {

	int position_right = map1[y][x + position_distance];
	int position_left = map1[y][x - position_distance];
	int position_up = map1[y - position_distance][x];
	int position_down = map1[y + position_distance][x];

	int bomberman_close = find_bomberman(&bomberman, x, y, dir, position_distance);
	if(bomberman_close) {
		return BOMBERMAN;
	} else {
		switch(dir) {
		case DIR_LEFT:
			return position_left;
			break;
		case DIR_RIGHT:
			return position_right;
			break;
		case DIR_UP:
			return position_up;
			break;
		case DIR_DOWN:
			return position_down;
			break;
		default:
			return -1;
		}
	}
}


static bool_t bomberman_move(unsigned char map[30][40], characters * bomberman, direction_t dir) {
	unsigned int x = bomberman->x;
	unsigned int y = bomberman->y;

	int i;
	int obstacle = 0;

	obstacle = obstacles_detection(x, y, map, dir, 1);
	if(obstacle == BACKGROUND || obstacle == DOOR) {
		switch(dir) {
		case DIR_LEFT:
			x -= 1;
			break;
		case DIR_RIGHT:
			x += 1;
			break;
		case DIR_UP:
			y -= 1;
			break;
		case DIR_DOWN:
			y += 1;
			break;
		default:
			break;
		}
		bomberman->x = x;
		bomberman->y = y;
	} else if(obstacle == ENEMY) {
		//KADA DODIRNEMO NEPRIJATELJA RESETUJEMO SE NA POCETNU i SMANJUJU SE ZIVOTI
		lives--;
		bomberman->x = BOMBERMAN_STARTING_POSITION_X;
		bomberman->y = BOMBERMAN_STARTING_POSITION_Y;
	}

	Xil_Out32(
			XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + bomberman->reg_h ),
			((y*16) << 16) | (x*16));

	for (i = 0; i < 1000000; i++) {
	}

	return b_false;
}

static void destroy_enemy(enemy * enm, int x, int y, direction_t dir, int distance){
	unsigned char flag = 0;

	switch(dir) {
	case DIR_LEFT:
		if((enm->x == x - distance) && enm->y == y){
				flag = 1;
			}
		break;
	case DIR_RIGHT:
		if((enm->x == x + distance) && enm->y == y){
				flag = 1;
			}
		break;
	case DIR_UP:
		if(enm->x == x && enm->y == (y - distance)){
				flag = 1;
			}
		break;
	case DIR_DOWN:
		if(enm->x == x && enm->y == (y + distance)){
				flag = 1;
			}
		break;
	default:
		break;
	}

	if(flag) {
		enm->destroyed = 1;
		enm->type = 0;
		enm->x = 0;
		enm->y = 0;
		enemies_destroyed++;
	}
}

//Brisanje polja u prosledjenom pravcu na distanci distance
static void destroy_field(int x, int y, characters * bomberman, unsigned char map[30][40], direction_t dir, int distance) {
	switch(dir) {
	case DIR_LEFT:
		map1[y][x - distance] = BACKGROUND;
		break;
	case DIR_RIGHT:
		map1[y][x + distance] = BACKGROUND;
		break;
	case DIR_UP:
		map1[y - distance][x] = BACKGROUND;
		break;
	case DIR_DOWN:
		map1[y + distance][x] = BACKGROUND;
		break;
	default:;
	}
}


static void destroy(unsigned char map[30][40], int x, int y, characters * bomberman, int bomb_power){
	int directions, i, j;
	unsigned short stop_flag;
	int explosion_obstacle;

	for(directions = 0; directions < 4; directions++) {
		for(i = 0; i <= bomb_power; i++) {
			stop_flag = 0;
			explosion_obstacle = explosion_detection(x, y, map1, (direction_t)directions, i);
			switch(explosion_obstacle) {
			case BACKGROUND:
				destroy_field(x, y, bomberman, map1, (direction_t)directions, i);
				break;
			case BOMBERMAN:
				lives--;
				bomberman->x = BOMBERMAN_STARTING_POSITION_X;
				bomberman->y = BOMBERMAN_STARTING_POSITION_Y;
				char_spawn(bomberman);
				break;
			case BRICK:
				destroy_field(x, y, bomberman, map1, (direction_t)directions, i);
				stop_flag = 1;
				break;
			case BLOCK:
				stop_flag = 1;
				break;
			case ENEMY:
				//OVDE SAM UBACIO DA SE ITERIRA KROZ NEPRIJATELJE
				//TO NAM DAJE DA MOZEMO DA BIRAMO KOLIKO CEMO NEPRIJATELJA
				for(j = 0; j < ENEMY_NUMBER; j++) {
					if(!enemies[j].destroyed) {
						destroy_enemy(&enemies[j], x, y, (direction_t)directions, i);
					}
				}

				destroy_field(x, y, bomberman, map1, (direction_t)directions, i);
				if(enemies_destroyed == 4) {
					map1[12][18] = DOOR;
					win_condition = bomberman_win(bomberman);
					if(win_condition) {
						map_update(bomberman);
					}
				}
				break;
			default:;
			}

			if(stop_flag) {
				break;
			}
		}
	}

	/*//left
	for(i = 1; i <= bomb_power; i++) {
		unsigned char stop_flag = 0;
		obstacle_left = explosion_detection(x, y, map1, DIR_LEFT, i);
		switch(obstacle_left) {
		case BACKGROUND:
			destroy_field(x, y, bomberman, map1, DIR_LEFT, i);
			break;
		case BOMBERMAN:
			lives--;
			break;
		case BRICK:
			destroy_field(x, y, bomberman, map1, DIR_LEFT, i);
			stop_flag = 1;
			break;
		case BLOCK:
			stop_flag = 1;
			break;
		case ENEMY:
			//OVDE SAM UBACIO DA SE ITERIRA KROZ NEPRIJATELJE
			//TO NAM DAJE DA MOZEMO DA BIRAMO KOLIKO CEMO NEPRIJATELJA
			for(j = 0; j < ENEMY_NUMBER; j++) {
				if(!enemies[j].destroyed) {
					destroy_enemy_at(&enemies[j], x - i, y);
				}
			}

			destroy_field(x, y, bomberman, map1, DIR_LEFT, i);
			if(enemies_destroyed == 4) {
				map1[12][18] = DOOR;
				win_condition = bomberman_win(bomberman);
				if(win_condition) {
					map_update(bomberman);
				}
			}
		}
		if(stop_flag) {
			break;
		}
	}

	//Right
	for(i = 1; i <= bomb_power; i++) {
		unsigned char stop_flag = 0;
		obstacle_right = explosion_detection(x, y, map1, DIR_RIGHT, i);
		switch(obstacle_right) {
		case BACKGROUND:
			destroy_field(x, y, bomberman, map1, DIR_RIGHT, i);
			break;
		case BOMBERMAN:
			lives--;
			break;
		case BRICK:
			destroy_field(x, y, bomberman, map1, DIR_RIGHT, i);
			stop_flag = 1;
			break;
		case BLOCK:
			stop_flag = 1;
			break;
		case ENEMY:
			//OVDE SAM UBACIO DA SE ITERIRA KROZ NEPRIJATELJE
			//TO NAM DAJE DA MOZEMO DA BIRAMO KOLIKO CEMO NEPRIJATELJA
			for(j = 0; j < ENEMY_NUMBER; j++) {
				if(!enemies[j].destroyed) {
					destroy_enemy_at(&enemies[j], x + i, y);
				}
			}
			destroy_field(x, y, bomberman, map1, DIR_RIGHT, i);
			if(enemies_destroyed == 4) {
				map1[12][18] = DOOR;
				win_condition = bomberman_win(bomberman);
				if(win_condition) {
					map_update(bomberman);
				}
			}
		}
		if(stop_flag) {
			break;
		}
	}

	//Up
	for(i = 1; i <= bomb_power; i++) {
		unsigned char stop_flag = 0;
		obstacle_up = explosion_detection(x, y, map, DIR_UP, i);
		switch(obstacle_up) {
		case BACKGROUND:
			destroy_field(x, y, bomberman, map1, DIR_UP, i);
			break;
		case BOMBERMAN:
			lives--;
			break;
		case BRICK:
			destroy_field(x, y, bomberman, map1, DIR_UP, i);
			stop_flag = 1;
			break;
		case BLOCK:
			stop_flag = 1;
			break;
		case ENEMY:
			//OVDE SAM UBACIO DA SE ITERIRA KROZ NEPRIJATELJE
			//TO NAM DAJE DA MOZEMO DA BIRAMO KOLIKO CEMO NEPRIJATELJA
			for(j = 0; j < ENEMY_NUMBER; j++) {
				if(!enemies[j].destroyed) {
					destroy_enemy_at(&enemies[j], x, y - i);
				}
			}
			destroy_field(x, y, bomberman, map1, DIR_UP, i);
			if(enemies_destroyed == 4) {
				map1[12][18] = DOOR;
				win_condition = bomberman_win(bomberman);
				if(win_condition) {
					map_update(bomberman);
				}
			}
		}
		if(stop_flag) {
			break;
		}
	}

	//Down
	for(i = 1; i <= bomb_power; i++) {
		unsigned char stop_flag = 0;
		obstacle_down = explosion_detection(x, y, map1, DIR_DOWN, i);
		switch(obstacle_down) {
		case BACKGROUND:
			destroy_field(x, y, bomberman, map1, DIR_DOWN, i);
			break;
		case BOMBERMAN:
			lives--;
			break;
		case BRICK:
			destroy_field(x, y, bomberman, map1, DIR_DOWN, i);
			stop_flag = 1;
			break;
		case BLOCK:
			stop_flag = 1;
			break;
		case ENEMY:
			//OVDE SAM UBACIO DA SE ITERIRA KROZ NEPRIJATELJE
			//TO NAM DAJE DA MOZEMO DA BIRAMO KOLIKO CEMO NEPRIJATELJA
			for(j = 0; j < ENEMY_NUMBER; j++) {
				if(!enemies[j].destroyed) {
					destroy_enemy_at(&enemies[j], x, y + i);
				}
			}
			destroy_field(x, y, bomberman, map1, DIR_DOWN, i);
			if(enemies_destroyed == 4) {
				map1[12][18] = DOOR;
				win_condition = bomberman_win(bomberman);
				if(win_condition) {
					map_update(bomberman);
				}
			}
		}
		if(stop_flag) {
			break;
		}
	}*/
}

static void random_move_enemy(enemy * enm, unsigned char map[30][40])
{
	int i = 0;
	direction_t dir = (direction_t)(rand()%4);
	int x = enm->x;
	int y = enm->y;
	int fb = find_bomberman(&bomberman, x, y, dir, 1);
	int obstacle = obstacles_detection(x, y, map1, dir, 1);
	if(!enm->destroyed) {
		if(!((enm->current_wait_cycle++)%ENEMY_WAIT_CYCLE_NUMBER)) {
			if(obstacle == BACKGROUND || fb) {
				map1[y][x] = BACKGROUND;
				switch(dir) {
				case DIR_LEFT:
					x -= 1;
					break;
				case DIR_RIGHT:
					x += 1;
					break;
				case DIR_UP:
					y -= 1;
					break;
				case DIR_DOWN:
					y += 1;
					break;
				default:;
				}
				map1[y][x] = enm->type;
				enm->x = x;
				enm->y = y;
				if(fb) {
					lives--;
					bomberman.x = BOMBERMAN_STARTING_POSITION_X;
					bomberman.y = BOMBERMAN_STARTING_POSITION_Y;
					char_spawn(&bomberman);
				}
			}
		}
	} else {
		enm->type = BACKGROUND;
		map1[y][x] = BACKGROUND;
	}
	for (i = 0; i < 100000; i++) {
	}
}

static void place_bomb(characters * bomberman) {
	unsigned char x = bomberman->x;
	unsigned char y = bomberman->y;
	if(map1[y][x] == BACKGROUND || map1[y][x] == BOMBERMAN) {
		unsigned char pom = (active_bombs_index++)%3; //cirkularni buffer za ove sto nisu eksplodirale
		bombs_coordinates[pom][0] = y; //KOD NJIH PRVO IDE Y KOORDINATA IZ NEKOG RAZLOGA
		bombs_coordinates[pom][1] = x;
		bombs_tick_counter[pom] = BOMB_TICK_COUNT;
		map1[y][x] = BOMB;
		active_bombs++;
	}
}

static void check_and_detonate_bombs() {
	unsigned char i;
	if(active_bombs > 0){
		unsigned char pom = 0;
		for(i = 0; i < 3; i++) {
			if(bombs_tick_counter[i]-- == 0){
				pom = (exploding_bombs_index++)%3; //Cirkularni buffer za eksplodirajuce

				map1[bombs_coordinates[pom][0]][bombs_coordinates[pom][1]] = BACKGROUND;
				destroy(map1, bombs_coordinates[pom][1], bombs_coordinates[pom][0], &bomberman, 2); //POSLEDNJI PARAMETAR JE JACINA BOMBE

				active_bombs--;
			}
		}
	}
}

static void check_and_destroy_enemies() {
	unsigned char i;
	for(i = 0; i < ENEMY_NUMBER; i++) {
		if(!enemies[i].destroyed) {
			random_move_enemy(&enemies[i], map1);
		}
	}
}

void battle_city() {
	unsigned int buttons;
	int i;

	map_reset(map1);
	map_update(&bomberman);
	char_spawn(&bomberman);

	//int x, y;
	//int bombs_coordinates[3][2], active_bombs_index = 0, exploding_bombs_index = 0;
	//int bombs_tick_counter[3] = {-1, -1, -1}; //nema postavljenih
	//int pom;
	int available_bombs = 3;

	map1[enemy1Y][enemy1X] = 5;

	map1[enemy2Y][enemy2X] = 5;

	map1[enemy3Y][enemy3X] = 5;

	map1[enemy4Y][enemy4X] = 5;

	while (1) {
		buttons = XIo_In32( XPAR_IO_PERIPH_BASEADDR );

		direction_t d = DIR_STILL;
		if(!win_condition && !lose_condition) {
			if (BTN_LEFT(buttons)) {
				d = DIR_LEFT;
			} else if (BTN_RIGHT(buttons)) {
				d = DIR_RIGHT;
			} else if (BTN_UP(buttons)){
				d = DIR_UP;
			} else if (BTN_DOWN(buttons)){
				d = DIR_DOWN;
			} else if(BTN_SHOOT(buttons) && active_bombs < available_bombs){

				place_bomb(&bomberman);
			}
		}


		//Ovde se ulazi kad istekne bomba

		check_and_detonate_bombs();

		check_and_destroy_enemies();

		map_update(&bomberman);

		bomberman_move(map1, &bomberman, d);

		for (i = 0; i < 100000; i++) {
		}

	}
}

